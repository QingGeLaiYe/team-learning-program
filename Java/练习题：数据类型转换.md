## 实例1：演示隐式转换时自动提升精度的效果
创建ImplicitConyersion类，让低精度的变量与高精度变量同时做计算，查看计算结果属于哪种精度，实例代码如下∶
```java
public class ImplicitConversion {
	public static void main(String[] args) {
		// 声明byte型变量mybyte，并把byte型变量允许的最大值赋给mybyte
		byte mybyte = 127;
		int myint = 150; 				// 声明int型变量myint，并赋值150
		float myfloat = 452.12f; 		// 声明float型变量myfloat，并赋值
		char mychar = 10;			// 声明char型变量mychar，并赋值
		double mydouble = 45.46546;	// 声明double型变量，并赋值
		/* 将运算结果输出 */
		System.out.println("byte型与float型数据进行运算结果为：" + (mybyte + myfloat));
		System.out.println("byte型与int型数据进行运算结果为：" + mybyte * myint);
		System.out.println("byte型与char型数据进行运算结果为：" + mybyte / mychar);
		System.out.println("double型与char型数据进行运算结果为：" + (mydouble + mychar));
	}
}
```

## 实例2：利用显式转换演示精度丢失
创建 ExplicitConversion类，使用显式转换将不同类型的变量转换成精度更低的类型，输出转换之后发生精度丢失的结果，实例代码如下∶
```java

public class ExplicitConversion {
	public static void main(String[] args) {
		int a = (int) 45.23; 			// double类型强制转化成int类型
		long b = (long) 456.6F; 		// flaot类型强制转化成long类型
		char c = (char) 97.14;		// double型强制转换成char型
		System.out.println("45.23强制转换成int的结果：" + a);
		System.out.println("456.6F强制转换成long的结果：" + b);
		System.out.println("97.14强制转换成char的结果" + c);
	}
}
```
#### 练习1：使用 char型声明'a'～'g'，然后输出它们相加后的结果。
#### 练习2：IP地址每段数字的最大值可以由byte型的最大值与 short型128相加后得到，使用隐式转换控制台输出 IP 地址每段数字的最大值。
#### 练习3：将 65～71显式转换为 char 型并输出。
#### 练习4：一辆货车运输箱子，载货区宽2米，长 4米，一个箱子宽 1.5 米，长 1.5米，请问载货区一层可以放多少个箱子?